Referencia de API
================

Esta sección proporciona documentación comprehensiva de las APIs públicas de Flash Sheet, clases, métodos e interfaces.

Clases Core
-----------

DataHandler
~~~~~~~~~~~

El componente central de gestión de datos.

**Firma de Clase:**

.. code-block:: python

   class DataHandler(QObject):
       # Señales
       data_loaded = Signal(DataFrame)
       progress_updated = Signal(int)
       error_occurred = Signal(str)

**Métodos Clave:**

.. py:method:: load_file(file_path: str, **options) -> DataFrame

   Cargar datos desde un archivo.

   :param file_path: Ruta al archivo de datos
   :param options: Opciones de carga (encoding, delimiter, etc.)
   :returns: DataFrame cargado
   :raises: FileNotFoundError, UnsupportedFormatError

.. py:method:: load_folder(folder_path: str, **options) -> DataFrame

   Cargar y consolidar múltiples archivos desde una carpeta.

   :param folder_path: Ruta a carpeta conteniendo archivos de datos
   :param options: Opciones de consolidación
   :returns: DataFrame consolidado

.. py:method:: export_data(data: DataFrame, format: str, destination: str, **options)

   Exportar datos a formato especificado.

   :param data: DataFrame a exportar
   :param format: Formato de exportación ('csv', 'excel', 'json', etc.)
   :param destination: Ruta de archivo de salida
   :param options: Opciones específicas de formato

MainWindow
~~~~~~~~~~

Ventana principal de aplicación y coordinador.

**Firma de Clase:**

.. code-block:: python

   class MainWindow(QMainWindow):
       def __init__(self)

**Métodos Clave:**

.. py:method:: switch_to_view(view_name: str)

   Cambiar a vista especificada de aplicación.

   :param view_name: Nombre de vista a activar

.. py:method:: load_file()

   Abrir diálogo de archivo y cargar archivo de datos.

.. py:method:: export_data(format: str)

   Exportar datos actuales en formato especificado.

Clases de Vista
---------------

BaseView
~~~~~~~~

Clase abstracta base para todas las vistas de aplicación.

**Firma de Clase:**

.. code-block:: python

   class BaseView(QWidget):
       # Señales
       data_changed = Signal()
       export_requested = Signal(str)

**Métodos Abstractos:**

.. py:method:: setup_ui()

   Inicializar interfaz de usuario de la vista.

.. py:method:: update_display()

   Refrescar visualización con datos actuales.

**Métodos Concretos:**

.. py:method:: set_data(data: DataFrame)

   Cargar datos en la vista.

   :param data: DataFrame a mostrar

.. py:method:: get_data() -> DataFrame

   Recuperar datos actuales de la vista.

   :returns: DataFrame actual

DataView
~~~~~~~~

Vista de tabla de datos principal.

**Firma de Clase:**

.. code-block:: python

   class DataView(BaseView):
       def __init__(self, parent=None)

**Métodos Clave:**

.. py:method:: apply_filter(filter_config: dict)

   Aplicar filtrado a los datos mostrados.

   :param filter_config: Diccionario de configuración de filtro

.. py:method:: sort_by_column(column: int, order: Qt.SortOrder)

   Ordenar datos por columna especificada.

   :param column: Índice de columna a ordenar
   :param order: Orden de clasificación (Ascending/Descending)

.. py:method:: set_pagination_enabled(enabled: bool, page_size: int = 100)

   Habilitar o deshabilitar paginación de datos.

   :param enabled: Si habilitar paginación
   :param page_size: Número de filas por página

GraphicsView
~~~~~~~~~~~~

Vista de creación de gráficos y visualización.

**Firma de Clase:**

.. code-block:: python

   class GraphicsView(BaseView):
       def __init__(self, parent=None)

**Métodos Clave:**

.. py:method:: create_chart(chart_type: str, config: dict) -> QChart

   Crear un gráfico de tipo especificado.

   :param chart_type: Tipo de gráfico ('bar', 'line', 'pie', etc.)
   :param config: Diccionario de configuración de gráfico
   :returns: Objeto QChart creado

.. py:method:: export_chart(format: str, destination: str)

   Exportar gráfico actual a archivo.

   :param format: Formato de exportación ('png', 'svg', 'pdf')
   :param destination: Ruta de archivo de salida

Clases de Características Avanzadas
-----------------------------------

DataJoinManager
~~~~~~~~~~~~~~~

Gestiona operaciones de unión de datos entre datasets.

**Firma de Clase:**

.. code-block:: python

   class DataJoinManager:
       def __init__(self)

**Métodos Clave:**

.. py:method:: perform_join(left_df: DataFrame, right_df: DataFrame, config: dict) -> DataFrame

   Realizar operación de unión entre dos DataFrames.

   :param left_df: DataFrame izquierdo
   :param right_df: DataFrame derecho
   :param config: Configuración de unión
   :returns: DataFrame unificado

**Configuración de Unión:**

.. code-block:: python

   join_config = {
       'type': 'inner',  # 'inner', 'left', 'right', 'cross'
       'left_keys': ['id'],  # Nombres de columna para DataFrame izquierdo
       'right_keys': ['customer_id'],  # Nombres de columna para DataFrame derecho
       'suffixes': ('_left', '_right'),  # Sufijos para columnas duplicadas
       'indicator': False  # Agregar columna indicador de merge
   }

ExcelTemplateSplitter
~~~~~~~~~~~~~~~~~~~~~

Maneja exportaciones separadas basadas en plantillas.

**Firma de Clase:**

.. code-block:: python

   class ExcelTemplateSplitter:
       def __init__(self)

**Métodos Clave:**

.. py:method:: split_by_template(df: DataFrame, separation_column: str, template_path: str, output_dir: str, **options) -> list

   Dividir DataFrame y exportar usando plantilla Excel.

   :param df: DataFrame de entrada
   :param separation_column: Columna para dividir por
   :param template_path: Ruta a plantilla Excel
   :param output_dir: Directorio de salida
   :param options: Opciones de exportación
   :returns: Lista de resultados de exportación

**Opciones de Exportación:**

.. code-block:: python

   export_options = {
       'filename_template': '{value}_{date}.xlsx',  # Patrón de nombre de archivo de salida
       'sheet_name': 'Data',  # Hoja en plantilla para inserción de datos
       'start_row': 2,  # Fila inicial para inserción de datos
       'start_col': 1,  # Columna inicial para inserción de datos
       'preserve_formatting': True  # Mantener formato de plantilla
   }

PivotTableManager
~~~~~~~~~~~~~~~~~

Gestiona creación y operaciones de tablas pivote.

**Firma de Clase:**

.. code-block:: python

   class PivotTableManager:
       def __init__(self)

**Métodos Clave:**

.. py:method:: create_pivot(df: DataFrame, config: dict) -> DataFrame

   Crear tabla pivote desde DataFrame.

   :param df: DataFrame de entrada
   :param config: Configuración de pivote
   :returns: DataFrame de tabla pivote

**Configuración de Pivote:**

.. code-block:: python

   pivot_config = {
       'values': ['sales', 'quantity'],  # Columnas de valor a agregar
       'index': ['region', 'product'],  # Columnas de agrupamiento de fila
       'columns': ['month'],  # Columnas de agrupamiento de columna
       'aggfunc': 'sum',  # Función de agregación
       'fill_value': 0,  # Llenar valores faltantes
       'margins': True  # Agregar totales
   }

Clases Utilitarias
------------------

DataValidator
~~~~~~~~~~~~~

Utilidades de validación y control de calidad de datos.

**Firma de Clase:**

.. code-block:: python

   class DataValidator:
       @staticmethod
       def validate_dataframe(df: DataFrame) -> dict

**Resultados de Validación:**

.. code-block:: python

   validation_result = {
       'is_valid': True,
       'errors': [],
       'warnings': [],
       'statistics': {
           'total_rows': 1000,
           'total_columns': 5,
           'null_counts': {'col1': 10, 'col2': 0},
           'data_types': {'col1': 'int64', 'col2': 'object'}
       }
   }

FileFormatDetector
~~~~~~~~~~~~~~~~~~

Detección automática de formato de archivo.

**Firma de Clase:**

.. code-block:: python

   class FileFormatDetector:
       @staticmethod
       def detect_format(file_path: str) -> str

**Formatos Soportados:**

- 'csv': Valores separados por coma
- 'excel': Microsoft Excel (.xlsx, .xls)
- 'json': Notación de Objetos JavaScript
- 'parquet': Apache Parquet
- 'hdf5': Formato de Datos Jerárquicos
- 'sql': Conexión de base de datos SQL

TypeInferer
~~~~~~~~~~~

Inferencia automática de tipos de datos y conversión.

**Firma de Clase:**

.. code-block:: python

   class TypeInferer:
       @staticmethod
       def infer_types(df: DataFrame) -> DataFrame

**Reglas de Inferencia de Tipos:**

- Strings numéricas → int64/float64
- Strings de fecha → datetime64
- Categorías consistentes → category
- Tipos mixtos → object

Excepciones
-----------

Clases de excepción personalizadas para manejo de errores.

DataHandlerError
~~~~~~~~~~~~~~~~

Excepción base para operaciones de manejo de datos.

.. code-block:: python

   class DataHandlerError(Exception):
       pass

FileOperationError
~~~~~~~~~~~~~~~~~~

Errores de operaciones de archivo.

.. code-block:: python

   class FileOperationError(DataHandlerError):
       def __init__(self, file_path, operation, message):
           self.file_path = file_path
           self.operation = operation
           super().__init__(message)

UnsupportedFormatError
~~~~~~~~~~~~~~~~~~~~~~

Errores de formato de archivo no soportado.

.. code-block:: python

   class UnsupportedFormatError(DataHandlerError):
       def __init__(self, format_type):
           self.format_type = format_type
           super().__init__(f"Formato no soportado: {format_type}")

ValidationError
~~~~~~~~~~~~~~~

Fallos de validación de datos.

.. code-block:: python

   class ValidationError(DataHandlerError):
       def __init__(self, issues):
           self.issues = issues
           super().__init__(f"Validación fallida: {issues}")

JoinError
~~~~~~~~~

Errores de operación de unión.

.. code-block:: python

   class JoinError(DataHandlerError):
       def __init__(self, message, left_keys=None, right_keys=None):
           self.left_keys = left_keys
           self.right_keys = right_keys
           super().__init__(message)

ExportError
~~~~~~~~~~~

Errores de operación de exportación.

.. code-block:: python

   class ExportError(DataHandlerError):
       def __init__(self, format_type, destination, message):
           self.format_type = format_type
           self.destination = destination
           super().__init__(message)

Configuración
-------------

Configuración de Aplicación
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Gestión de configuración para configuraciones de aplicación.

**Estructura de Archivo de Configuración:**

.. code-block:: yaml

   application:
     theme: 'light'  # 'light' o 'dark'
     language: 'en'  # Código de idioma
     max_memory: '2GB'  # Límite de memoria

   data:
     default_encoding: 'utf-8'
     chunk_size: 10000
     cache_enabled: true

   export:
     default_format: 'csv'
     compression: true
     template_dir: './templates'

**Acceso a Configuración:**

.. code-block:: python

   from config import get_config

   config = get_config()
   theme = config.get('application.theme', 'light')

Señales y Eventos
-----------------

Referencia de Señales Qt
~~~~~~~~~~~~~~~~~~~~~~~~

**Señales de DataHandler:**

- ``data_loaded(DataFrame)``: Emitido cuando datos son cargados exitosamente
- ``progress_updated(int)``: Porcentaje de progreso para operaciones largas (0-100)
- ``error_occurred(str)``: Mensajes de error con contexto

**Señales de Vista:**

- ``data_changed()``: Emitido cuando datos de vista son modificados
- ``export_requested(str)``: Solicitud para exportar datos en formato especificado
- ``view_closed()``: Emitido cuando vista es cerrada

**Señales de MainWindow:**

- ``view_switched(str)``: Emitido cuando vista activa cambia
- ``operation_started(str)``: Operación larga iniciada
- ``operation_completed(str)``: Operación larga completada

Ejemplos de Manejo de Eventos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   # Conectando a señales de DataHandler
   data_handler.data_loaded.connect(self.on_data_loaded)
   data_handler.progress_updated.connect(self.update_progress_bar)
   data_handler.error_occurred.connect(self.show_error_message)

   # Manejo de señales de vista
   current_view.data_changed.connect(self.update_window_title)
   current_view.export_requested.connect(self.handle_export_request)

Constantes y Enums
------------------

Tipos de Datos
~~~~~~~~~~~~~~

.. code-block:: python

   class DataType:
       STRING = 'string'
       INTEGER = 'int64'
       FLOAT = 'float64'
       DATETIME = 'datetime64'
       BOOLEAN = 'bool'
       CATEGORY = 'category'

Tipos de Unión
~~~~~~~~~~~~~~

.. code-block:: python

   class JoinType:
       INNER = 'inner'
       LEFT = 'left'
       RIGHT = 'right'
       OUTER = 'outer'
       CROSS = 'cross'

Formatos de Exportación
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   class ExportFormat:
       CSV = 'csv'
       EXCEL = 'excel'
       JSON = 'json'
       PARQUET = 'parquet'
       HDF5 = 'hdf5'
       SQL = 'sql'
       PDF = 'pdf'
       PNG = 'png'
       SVG = 'svg'

Tipos de Gráfico
~~~~~~~~~~~~~~~~

.. code-block:: python

   class ChartType:
       BAR = 'bar'
       LINE = 'line'
       PIE = 'pie'
       SCATTER = 'scatter'
       HISTOGRAM = 'histogram'
       BOX = 'box'
       AREA = 'area'
       HEATMAP = 'heatmap'

Métricas de Performance
-----------------------

Seguimiento de Uso de Memoria
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Monitorear consumo de memoria de aplicación:

.. code-block:: python

   class MemoryMonitor:
       @staticmethod
       def get_memory_usage() -> dict:
           """Obtener estadísticas de uso de memoria actual."""
           process = psutil.Process()
           memory_info = process.memory_info()

           return {
               'rss': memory_info.rss,  # Resident Set Size
               'vms': memory_info.vms,  # Virtual Memory Size
               'percent': process.memory_percent()
           }

Temporización de Operaciones
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Temporización de performance para operaciones:

.. code-block:: python

   class PerformanceTimer:
       def __init__(self, operation_name):
           self.operation_name = operation_name
           self.start_time = None

       def start(self):
           self.start_time = time.time()

       def stop(self):
           if self.start_time:
               duration = time.time() - self.start_time
               logger.info(f"{self.operation_name} completado en {duration:.2f}s")
               return duration

**Uso de Context Manager:**

.. code-block:: python

   with PerformanceTimer("carga_datos"):
       data = data_handler.load_file(file_path)

Puntos de Extensión
-------------------

Arquitectura de Plugin
~~~~~~~~~~~~~~~~~~~~~~

Sistema extensible de plugin para funcionalidad personalizada:

.. code-block:: python

   class PluginInterface(ABC):
       @abstractmethod
       def initialize(self, main_window):
           """Inicializar plugin con referencia de ventana principal."""
           pass

       @abstractmethod
       def get_menu_items(self) -> list:
           """Retornar items de menú a agregar al menú de aplicación."""
           pass

Fuentes de Datos Personalizadas
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Agregar soporte para fuentes de datos nuevas:

.. code-block:: python

   class CustomDataSource(ABC):
       @abstractmethod
       def can_handle(self, source_spec) -> bool:
           """Verificar si esta fuente puede manejar la especificación."""
           pass

       @abstractmethod
       def load_data(self, source_spec) -> DataFrame:
           """Cargar datos desde la fuente personalizada."""
           pass

**Registro:**

.. code-block:: python

   # Registrar fuente de datos personalizada
   data_handler.register_data_source(CustomDataSource())

Formatos de Exportación Personalizados
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Agregar soporte de formato de exportación nuevo:

.. code-block:: python

   class CustomExporter(ABC):
       @abstractmethod
       def get_format_name(self) -> str:
           """Retornar nombre de formato."""
           pass

       @abstractmethod
       def export(self, data: DataFrame, destination: str, **options):
           """Exportar datos a formato personalizado."""
           pass

**Registro:**

.. code-block:: python

   # Registrar exportador personalizado
   data_handler.register_exporter(CustomExporter())

Guía de Migración
-----------------

Compatibilidad de Versiones
~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Cambios de API por Versión:**

- **v1.0.0**: Release inicial de API
- **v1.1.0**: Agregadas operaciones async, manejo de errores mejorado

**Compatibilidad hacia Atrás:**

- Todas las APIs públicas mantienen compatibilidad hacia atrás
- Métodos obsoletos emiten warnings antes de eliminación
- Guías de migración provistas para versiones principales

Avisos de Deprecación
~~~~~~~~~~~~~~~~~~~~~

**Métodos Obsoletos:**

.. code-block:: python

   # Obsoleto en v1.1.0
   @deprecated("Usar load_file() en su lugar")
   def loadDataFile(self, file_path):
       return self.load_file(file_path)

**Ruta de Migración:**

1. Actualizar llamadas a métodos a nuevas firmas
2. Reemplazar clases obsoletas con implementaciones actuales
3. Actualizar archivos de configuración a nuevo formato
4. Probar con nueva versión antes de producción