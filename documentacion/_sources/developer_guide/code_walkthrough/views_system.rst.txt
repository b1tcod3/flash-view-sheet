Arquitectura del Sistema de Vistas
===============================

El sistema de vistas en Flash Sheet implementa arquitectura modular para mostrar e interactuar con diferentes tipos de datos y visualizaciones.

Resumen de Arquitectura
-----------------------

Jerarquía de Vistas
~~~~~~~~~~~~~~~~~~~

El sistema de vistas está construido alrededor de una clase View base con implementaciones especializadas:

- **BaseView**: Clase abstracta base definiendo interfaz común
- **MainView**: Vista inicial con opciones de carga de datos
- **DataView**: Visualización primaria de tabla de datos con herramientas de manipulación
- **GraphicsView**: Interfaz de creación de gráficos y visualización
- **JoinedDataView**: Vista especializada para resultados de operaciones de join
- **PivotView**: Interfaz de creación y edición de tablas pivote

Gestión de Vistas
~~~~~~~~~~~~~~~~~

Las vistas son gestionadas a través del QStackedWidget de MainWindow:

.. code-block:: python

   class ViewManager:
       def __init__(self, stacked_widget):
           self.stacked_widget = stacked_widget
           self.views = {}
           self.current_view = None

       def register_view(self, name, view_instance):
           self.views[name] = view_instance
           self.stacked_widget.addWidget(view_instance)

       def switch_to_view(self, name):
           if name in self.views:
               self.stacked_widget.setCurrentWidget(self.views[name])
               self.current_view = name
               self.views[name].on_activated()

Interfaz Base de Vista
----------------------

Interfaz Común
~~~~~~~~~~~~~~

Todas las vistas implementan interfaz estándar para consistencia:

.. code-block:: python

   class BaseView(QWidget):
       # Señales
       data_changed = Signal()
       view_closed = Signal()
       export_requested = Signal(str)  # formato

       def __init__(self, parent=None):
           super().__init__(parent)
           self.data = None
           self.setup_ui()

       def setup_ui(self):
           """Inicializar interfaz de usuario de la vista"""
           raise NotImplementedError

       def set_data(self, data):
           """Cargar datos en la vista"""
           self.data = data
           self.update_display()

       def get_data(self):
           """Recuperar datos actuales de la vista"""
           return self.data

       def clear_data(self):
           """Resetear vista a estado vacío"""
           self.data = None
           self.update_display()

       def get_export_data(self):
           """Preparar datos para exportación"""
           return self.data

       def update_display(self):
           """Refrescar visualización"""
           raise NotImplementedError

       def on_activated(self):
           """Llamado cuando vista se vuelve activa"""
           pass

Implementación DataView
-----------------------

Core de Visualización de Tabla
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

DataView proporciona interfaz primaria de tabla de datos:

.. code-block:: python

   class DataView(BaseView):
       def setup_ui(self):
           layout = QVBoxLayout()

           # Barra de herramientas
           self.toolbar = self.create_toolbar()
           layout.addWidget(self.toolbar)

           # Widget de tabla
           self.table = QTableWidget()
           self.table.setAlternatingRowColors(True)
           self.table.setSortingEnabled(True)
           layout.addWidget(self.table)

           # Barra de estado
           self.status_label = QLabel()
           layout.addWidget(self.status_label)

           self.setLayout(layout)

Características de Tabla de Datos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Funcionalidad avanzada de tabla para exploración de datos:

.. code-block:: python

   def setup_table(self):
       # Habilitar ordenamiento
       self.table.setSortingEnabled(True)

       # Configurar comportamiento de selección
       self.table.setSelectionBehavior(QTableWidget.SelectRows)

       # Configurar encabezados
       horizontal_header = self.table.horizontalHeader()
       horizontal_header.setStretchLastSection(True)
       horizontal_header.setSectionsMovable(True)

       # Conectar señales
       self.table.itemChanged.connect(self.on_item_changed)
       self.table.itemSelectionChanged.connect(self.on_selection_changed)

Sistema de Paginación
~~~~~~~~~~~~~~~~~~~~~

Manejo eficiente de datasets grandes:

.. code-block:: python

   class PaginationWidget(QWidget):
       def __init__(self, table_view, page_size=100):
           super().__init__()
           self.table_view = table_view
           self.page_size = page_size
           self.current_page = 0
           self.total_pages = 0

           self.setup_ui()

       def setup_ui(self):
           layout = QHBoxLayout()

           self.first_btn = QPushButton("<<")
           self.prev_btn = QPushButton("<")
           self.page_label = QLabel("Página 1 de 1")
           self.next_btn = QPushButton(">")
           self.last_btn = QPushButton(">>")

           layout.addWidget(self.first_btn)
           layout.addWidget(self.prev_btn)
           layout.addWidget(self.page_label)
           layout.addWidget(self.next_btn)
           layout.addWidget(self.last_btn)

           self.setLayout(layout)
           self.connect_signals()

Filtrado y Búsqueda
~~~~~~~~~~~~~~~~~~~~

Capacidades de filtrado de datos en tiempo real:

.. code-block:: python

   class FilterWidget(QWidget):
       def __init__(self, data_view):
           super().__init__()
           self.data_view = data_view
           self.filters = {}

           self.setup_ui()

       def setup_ui(self):
           layout = QVBoxLayout()

           # Búsqueda global
           self.search_box = QLineEdit()
           self.search_box.setPlaceholderText("Buscar todas las columnas...")
           layout.addWidget(self.search_box)

           # Filtros específicos de columna
           self.filter_layout = QVBoxLayout()
           layout.addLayout(self.filter_layout)

           self.setLayout(layout)
           self.connect_signals()

       def add_column_filter(self, column_name, data_type):
           if data_type == 'string':
               filter_widget = QLineEdit()
               filter_widget.setPlaceholderText(f"Filtrar {column_name}")
           elif data_type in ['int64', 'float64']:
               filter_widget = QHBoxLayout()
               min_spin = QSpinBox()
               max_spin = QSpinBox()
               filter_widget.addWidget(min_spin)
               filter_widget.addWidget(QLabel("-"))
               filter_widget.addWidget(max_spin)
           # Agregar filtros de fecha, etc.

           self.filters[column_name] = filter_widget
           self.filter_layout.addWidget(filter_widget)

Implementación GraphicsView
---------------------------

Interfaz de Creación de Gráficos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Vista de visualización para crear y gestionar gráficos:

.. code-block:: python

   class GraphicsView(BaseView):
       def setup_ui(self):
           layout = QVBoxLayout()

           # Selector de tipo de gráfico
           self.chart_type_combo = QComboBox()
           self.chart_type_combo.addItems([
               'Gráfico de Barras', 'Gráfico de Líneas', 'Gráfico de Torta',
               'Gráfico de Dispersión', 'Histograma', 'Gráfico de Caja'
           ])
           layout.addWidget(self.chart_type_combo)

           # Configuración de gráfico
           self.config_widget = ChartConfigWidget()
           layout.addWidget(self.config_widget)

           # Área de visualización de gráfico
           self.chart_view = QChartView()
           layout.addWidget(self.chart_view)

           # Opciones de exportación
           self.export_widget = ChartExportWidget()
           layout.addWidget(self.export_widget)

           self.setLayout(layout)

Configuración de Gráfico
~~~~~~~~~~~~~~~~~~~~~~~~

Configuración dinámica de gráfico basada en tipo seleccionado:

.. code-block:: python

   class ChartConfigWidget(QWidget):
       def __init__(self):
           super().__init__()
           self.current_config = None

       def set_chart_type(self, chart_type):
           # Limpiar configuración previa
           self.clear_config()

           if chart_type == 'bar':
               self.current_config = BarChartConfig()
           elif chart_type == 'line':
               self.current_config = LineChartConfig()
           # etc.

           self.layout().addWidget(self.current_config)

       def get_chart_config(self):
           return self.current_config.get_config() if self.current_config else {}

Motor de Renderizado de Gráfico
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Integración Qt Charts para renderizado de alto performance:

.. code-block:: python

   def render_chart(self, config):
       chart = QChart()

       # Crear series basadas en config
       if config['type'] == 'bar':
           series = QBarSeries()
           for category, value in config['data'].items():
               bar_set = QBarSet(category)
               bar_set.append(value)
               series.append(bar_set)
       elif config['type'] == 'line':
           series = QLineSeries()
           for point in config['data']:
               series.append(point[0], point[1])

       chart.addSeries(series)

       # Configurar ejes
       axis_x = QBarCategoryAxis()
       axis_x.append(config['categories'])
       chart.setAxisX(axis_x, series)

       axis_y = QValueAxis()
       chart.setAxisY(axis_y, series)

       self.chart_view.setChart(chart)

Implementación JoinedDataView
-----------------------------

Vista Especializada de Resultados Join
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Interfaz dedicada para mostrar resultados de operaciones de join:

.. code-block:: python

   class JoinedDataView(BaseView):
       def setup_ui(self):
           layout = QVBoxLayout()

           # Visualización de metadatos de join
           self.metadata_widget = JoinMetadataWidget()
           layout.addWidget(self.metadata_widget)

           # Tabla de resultados
           self.results_table = QTableWidget()
           layout.addWidget(self.results_table)

           # Estadísticas de join
           self.stats_widget = JoinStatsWidget()
           layout.addWidget(self.stats_widget)

           self.setLayout(layout)

Visualización de Metadatos Join
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Información sobre operación de join realizada:

.. code-block:: python

   class JoinMetadataWidget(QWidget):
       def __init__(self):
           super().__init__()
           self.setup_ui()

       def setup_ui(self):
           layout = QFormLayout()

           self.join_type_label = QLabel()
           self.left_table_label = QLabel()
           self.right_table_label = QLabel()
           self.join_keys_label = QLabel()
           self.result_rows_label = QLabel()

           layout.addRow("Tipo de Join:", self.join_type_label)
           layout.addRow("Tabla Izquierda:", self.left_table_label)
           layout.addRow("Tabla Derecha:", self.right_table_label)
           layout.addRow("Claves de Join:", self.join_keys_label)
           layout.addRow("Filas Resultantes:", self.result_rows_label)

           self.setLayout(layout)

       def update_metadata(self, join_info):
           self.join_type_label.setText(join_info['type'])
           self.left_table_label.setText(join_info['left_table'])
           self.right_table_label.setText(join_info['right_table'])
           self.join_keys_label.setText(', '.join(join_info['keys']))
           self.result_rows_label.setText(str(join_info['result_count']))

Comunicación entre Vistas
-------------------------

Flujo de Datos Inter-Vistas
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Las vistas se comunican a través del coordinador MainWindow:

.. code-block:: python

   # En MainWindow
   def on_data_loaded(self, data):
       current_view = self.stacked_widget.currentWidget()
       if hasattr(current_view, 'set_data'):
           current_view.set_data(data)

   def on_view_changed(self, index):
       new_view = self.stacked_widget.widget(index)
       if hasattr(new_view, 'on_activated'):
           new_view.on_activated()

Actualizaciones Basadas en Señales
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Las vistas emiten señales para notificar cambios:

.. code-block:: python

   # En DataView
   def on_item_changed(self, item):
       # Actualizar datos internos
       row, col = item.row(), item.column()
       self.data.iloc[row, col] = item.text()

       # Notificar otros componentes
       self.data_changed.emit()

Gestión de Estado de Vista
~~~~~~~~~~~~~~~~~~~~~~~~~~

Preservando estado de vista durante cambios:

.. code-block:: python

   class ViewState:
       def __init__(self):
           self.scroll_position = 0
           self.selected_rows = []
           self.filter_settings = {}
           self.sort_column = 0
           self.sort_order = Qt.AscendingOrder

       def save_state(self, view):
           # Guardar estado actual de vista
           pass

       def restore_state(self, view):
           # Restaurar estado guardado
           pass

Optimización de Performance
--------------------------

Carga Lazy
~~~~~~~~~~

Cargar componentes de vista bajo demanda:

.. code-block:: python

   def load_view_components(self):
       if not self.components_loaded:
           # Cargar componentes pesados
           self.load_table_data()
           self.load_chart_components()
           self.components_loaded = True

Gestión de Memoria
~~~~~~~~~~~~~~~~~~

Uso eficiente de memoria para datasets grandes:

.. code-block:: python

   def optimize_for_large_data(self, data_size):
       if data_size > 100000:  # 100K filas
           # Deshabilitar ordenamiento en tiempo real
           self.table.setSortingEnabled(False)

           # Habilitar paginación
           self.enable_pagination()

           # Usar scrolling virtual
           self.enable_virtual_scrolling()

Scrolling Virtual
~~~~~~~~~~~~~~~~~

Mostrar datasets grandes sin cargar todos los datos:

.. code-block:: python

   class VirtualTableModel(QAbstractTableModel):
       def __init__(self, data_source, page_size=1000):
           super().__init__()
           self.data_source = data_source
           self.page_size = page_size
           self.current_page = 0
           self.cache = {}

       def rowCount(self, parent=QModelIndex()):
           return self.data_source.total_rows

       def columnCount(self, parent=QModelIndex()):
           return self.data_source.total_columns

       def data(self, index, role=Qt.DisplayRole):
           if role == Qt.DisplayRole:
               page = index.row() // self.page_size
               if page not in self.cache:
                   self.cache[page] = self.data_source.load_page(page)

               row_in_page = index.row() % self.page_size
               return self.cache[page].iloc[row_in_page, index.column()]

           return None

Testing y Assurance de Calidad
------------------------------

Framework de Testing de Vistas
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Testing comprehensivo para componentes de vista:

.. code-block:: python

   def test_data_view(self):
       # Crear datos de prueba
       test_df = pd.DataFrame({
           'A': [1, 2, 3],
           'B': ['x', 'y', 'z']
       })

       # Crear vista
       view = DataView()

       # Test carga de datos
       view.set_data(test_df)
       self.assertEqual(view.table.rowCount(), 3)
       self.assertEqual(view.table.columnCount(), 2)

       # Test recuperación de datos
       retrieved_data = view.get_data()
       pd.testing.assert_frame_equal(retrieved_data, test_df)

Accesibilidad y Usabilidad
--------------------------

Navegación por Teclado
~~~~~~~~~~~~~~~~~~~~~~

Accesibilidad completa por teclado:

- **Navegación por Tab**: Mover entre controles
- **Teclas de Flecha**: Navegar celdas de tabla
- **Enter/Espacio**: Activar botones y controles
- **Teclas de Atajo**: Operaciones comunes (Ctrl+C, Ctrl+V, etc.)

Soporte de Lector de Pantalla
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Características de accesibilidad para tecnologías asistivas:

.. code-block:: python

   def setup_accessibility(self):
       # Configurar nombres accesibles y descripciones
       self.table.setAccessibleName("Tabla de datos")
       self.table.setAccessibleDescription("Tabla de visualización principal de datos")

       # Configurar encabezados de tabla
       for col in range(self.table.columnCount()):
           header_item = self.table.horizontalHeaderItem(col)
           header_item.setAccessibleDescription(f"Columna {col + 1}")

Tema y Estilo
~~~~~~~~~~~~~

Apariencia personalizable:

.. code-block:: python

   def apply_theme(self, theme_name):
       if theme_name == 'dark':
           self.setStyleSheet("""
               QTableWidget {
                   background-color: #2b2b2b;
                   color: #ffffff;
               }
           """)
       elif theme_name == 'light':
           self.setStyleSheet("""
               QTableWidget {
                   background-color: #ffffff;
                   color: #000000;
               }
           """)

Mejoras Futuras
---------------

Mejoras Planificadas
~~~~~~~~~~~~~~~~~~~~

- **Filtrado Avanzado**: Multi-columna, regex, y filtros personalizados
- **Edición de Datos**: Edición in-place de celdas con validación
- **Vistas Colaborativas**: Edición simultánea multi-usuario
- **Plugins de Vista Personalizada**: Extensiones de vista de terceros
- **Visualización 3D**: Visualización tridimensional de datos
- **Actualizaciones en Tiempo Real**: Streaming de datos en vivo y actualizaciones