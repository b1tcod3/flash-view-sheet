Sistema de Arquitectura de Main Window - Recorrido Detallado del Código
===========================================================================

La clase MainWindow sirve como coordinador central para la aplicación Flash Sheet, gestionando el layout general de UI, cambio de vistas y estado de aplicación. Este recorrido proporciona análisis detallado línea por línea de secciones críticas de código.

Resumen de Arquitectura
-----------------------

MainWindow hereda de QMainWindow de PySide6 e implementa la ventana principal de aplicación con sistema de menú, barra de herramientas y widget apilado para gestión de vistas.

Responsabilidades Clave
~~~~~~~~~~~~~~~~~~~~~~~

- **Inicialización de UI**: Configurar menús, barras de herramientas y widget central
- **Gestión de Vistas**: Manejar cambio entre diferentes vistas de aplicación
- **Coordinación de Datos**: Gestionar flujo de datos entre componentes
- **Acciones de Menú**: Implementar operaciones de archivo, manipulación de datos y exportación
- **Actualizaciones de Estado**: Mostrar estado de aplicación e información de progreso

Análisis Detallado del Código
-----------------------------

Inicialización y Configuración
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Análisis de Constructor** (main.py líneas 47-92):

.. code-block:: python
   :linenos:

   class MainWindow(QMainWindow):
       """Ventana principal de la aplicación"""

       def __init__(self):
           super().__init__()
           self.setWindowTitle("Flash View Sheet - Visor de Datos Tabulares")
           self.setGeometry(100, 100, 1200, 800)

           # Inicializar componentes
           self.df_original = None
           self.df_vista_actual = None
           self.pandas_model = None
           self.loading_thread = None

**Explicación línea por línea:**

- **Línea 47**: Definición de clase heredando de QMainWindow (clase de ventana principal de PySide6)
- **Línea 50**: Llamar constructor padre para inicializar framework Qt
- **Línea 51**: Establecer título de ventana en español - decisión de diseño para audiencia objetivo
- **Línea 52**: Establecer geometría inicial de ventana (posición 100,100, tamaño 1200x800) - balanceado para la mayoría de pantallas
- **Líneas 55-59**: Inicializar atributos de datos clave:
  - ``df_original``: Almacena el dataset cargado original (preserva integridad de datos)
  - ``df_vista_actual``: Datos de vista actual (pueden estar filtrados/transformados)
  - ``pandas_model``: Modelo Qt para visualización de tabla
  - ``loading_thread``: Hilo de carga en segundo plano para capacidad de respuesta

**Decisión de Diseño**: Separar datos originales y vista actual permite filtrado/transformaciones sin perder datos originales.

**Análisis de Configuración de UI** (main.py líneas 93-102):

.. code-block:: python
   :linenos:

   def setup_ui(self):
       """Configurar la interfaz de usuario"""
       # Aquí se cargará la interfaz desde el archivo .ui
       # Por ahora, creamos una interfaz básica
       self.create_menu_bar()
       self.create_tool_bar()
       self.create_central_widget()
       self.create_status_bar()
       self.create_views()

**Explicación línea por línea:**

- **Línea 94**: Método para configurar componentes de interfaz de usuario
- **Líneas 96-97**: Comentarios indicando futura carga de archivo .ui (integración Qt Designer)
- **Línea 98**: Crear barra de menú con todos los menús de aplicación
- **Línea 99**: Crear barra de herramientas con botones de acceso rápido
- **Línea 100**: Crear widget central (contenedor de vistas apiladas)
- **Línea 101**: Crear barra de estado para mensajes y progreso
- **Línea 102**: Inicializar todos los componentes de vista

**Decisión de Diseño**: Métodos de configuración modulares permiten mantenimiento fácil y testing.

Sistema de Menú Implementación
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Creación de Menú Análisis** (main.py líneas 116-225):

.. code-block:: python
   :linenos:

   def create_menu_bar(self):
       """Crear la barra de menú"""
       menu_bar = self.menuBar()

       # Menú Archivo
       archivo_menu = menu_bar.addMenu("&Archivo")

       # Acción Abrir
       abrir_action = archivo_menu.addAction("&Abrir...")
       abrir_action.setShortcut("Ctrl+O")
       abrir_action.triggered.connect(self.abrir_archivo)

**Detalles críticos de implementación:**

- **Línea 117**: Obtener barra de menú de QMainWindow
- **Línea 121**: Crear menú "Archivo" con ampersand para navegación por teclado
- **Línea 124**: Crear acción "Abrir" con puntos suspensivos indicando diálogo
- **Línea 125**: Atajo estándar Ctrl+O para apertura de archivos
- **Línea 126**: Conectar acción a método slot

**Decisión de Diseño**: Nombres de menú en español para consistencia con idioma de aplicación.

**Integración de Menú Avanzado** (main.py líneas 166-225):

.. code-block:: python
   :linenos:

   # Nuevo Menú Separar
   separar_menu = menu_bar.addMenu("&Separar")

   # Acción Exportar Datos Separados
   exportar_separado_action = separar_menu.addAction("&Exportar Datos Separados...")
   exportar_separado_action.setShortcut("Ctrl+Shift+S")
   exportar_separado_action.triggered.connect(self.exportar_datos_separados)
   exportar_separado_action.setEnabled(False)  # Se habilita solo con datos cargados

**Explicación línea por línea:**

- **Línea 167**: Crear menú "Separar" para funcionalidad avanzada de exportación
- **Línea 170**: Acción para exportación basada en plantillas con nombre descriptivo
- **Línea 171**: Atajo único (Ctrl+Shift+S) para evitar conflictos
- **Línea 172**: Conectar a método de exportación
- **Línea 173**: Inicialmente deshabilitado - **decisión de diseño**: Solo habilitar cuando datos están cargados para prevenir errores

**Decisión de Diseño**: Los items de menú se habilitan/deshabilizan basados en estado de aplicación, proporcionando retroalimentación clara de usuario.

Pipeline de Carga de Datos
~~~~~~~~~~~~~~~~~~~~~~~~~~

**Análisis de Carga de Archivos** (main.py líneas 351-400):

.. code-block:: python
   :linenos:

   def abrir_archivo(self):
       """Slot para abrir un archivo"""
       from core.data_handler import get_supported_file_formats

       # Obtener formatos soportados dinámicamente
       supported_formats = get_supported_file_formats()

       # Crear filtro de archivos dinámico
       format_filters = []
       format_descriptions = {
           '.xlsx': 'Archivos de Excel',
           '.xls': 'Archivos de Excel Legacy',
           '.csv': 'Archivos CSV',
           '.tsv': 'Archivos TSV',
           '.json': 'Archivos JSON',
           '.xml': 'Archivos XML',
           '.parquet': 'Archivos Parquet',
           '.feather': 'Archivos Feather',
           '.hdf5': 'Archivos HDF5',
           '.h5': 'Archivos HDF5',
           '.pkl': 'Archivos Pickle',
           '.pickle': 'Archivos Pickle',
           '.db': 'Bases de Datos SQLite',
           '.sqlite': 'Bases de Datos SQLite',
           '.sqlite3': 'Bases de Datos SQLite',
           '.yaml': 'Archivos YAML',
           '.yml': 'Archivos YAML',
       }

**Detalles críticos de implementación:**

- **Línea 352**: Importar función de detección de formato desde módulo core
- **Línea 355**: Lista de formatos dinámica permite extensión fácil
- **Líneas 359-378**: Mapeo comprehensivo de formatos con descripciones amigables en español
- **Decisión de Diseño**: Sistema extensible de formatos - nuevos formatos pueden agregarse sin cambiar código UI

**Implementación de Carga con Hilos** (main.py líneas 401-415):

.. code-block:: python
   :linenos:

   def mostrar_loading_indicator(self, filepath, skip_rows=0, column_names=None):
       """Mostrar indicador de carga mientras se procesa el archivo"""

       # Crear y configurar el diálogo de progreso
       self.progress_dialog = QProgressDialog("Cargando archivo...", "Cancelar", 0, 100)
       self.progress_dialog.setWindowTitle("Cargando datos")
       self.progress_dialog.setWindowModality(Qt.WindowModal)
       self.progress_dialog.show()

       # Crear y ejecutar el hilo de carga
       self.loading_thread = DataLoaderThread(filepath, skip_rows, column_names)
       self.loading_thread.data_loaded.connect(self.on_datos_cargados)
       self.loading_thread.error_occurred.connect(self.on_error_carga)
       self.loading_thread.start()

**Explicación línea por línea:**

- **Línea 404**: Crear diálogo modal de progreso para bloquear UI durante carga
- **Línea 411**: Instanciar hilo de carga en segundo plano
- **Líneas 412-413**: Conectar señales de hilo a slots de ventana principal
- **Línea 414**: Iniciar procesamiento en segundo plano

**Decisión de Diseño**: Carga con hilos previene congelamiento de UI, crítico para datasets grandes.

Sistema de Gestión de Vistas
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Configuración de Widget Apilado** (main.py líneas 297-335):

.. code-block:: python
   :linenos:

   def create_central_widget(self):
       """Crear el widget central con stacked views"""
       # Crear stacked widget para las vistas
       self.stacked_widget = QStackedWidget()
       self.setCentralWidget(self.stacked_widget)

   def create_views(self):
       """Crear las vistas y añadirlas al stacked widget"""
       # Vista Principal (índice 0)
       self.main_view = MainView()
       self.main_view.file_loaded.connect(self.on_file_loaded_from_main_view)
       self.stacked_widget.addWidget(self.main_view)

       # Vista de Tabla (índice 1) - DataView con paginación
       self.data_view = DataView()
       self.stacked_widget.addWidget(self.data_view)

       # Vista de Información (índice 2) - modal
       # Se muestra mediante show_info_modal()

       # Vista de Gráficos (índice 3)
       self.graphics_view = GraphicsView()
       self.stacked_widget.addWidget(self.graphics_view)

       # Vista de Datos Cruzados (índice 4)
       self.joined_data_view = JoinedDataView()
       self.joined_data_view.new_join_requested.connect(self.abrir_cruzar_datos)
       self.stacked_widget.addWidget(self.joined_data_view)

**Detalles críticos de implementación:**

- **Línea 300**: QStackedWidget gestiona múltiples vistas en mismo espacio
- **Línea 311**: MainView maneja carga inicial de archivos
- **Línea 312**: Conectar señal de carga de archivos a ventana principal
- **Línea 316**: DataView con paginación para datasets grandes
- **Línea 329**: JoinedDataView para resultados de operaciones de join
- **Línea 330**: Conectar señal de solicitud de join

**Decisión de Diseño**: Widget apilado permite cambio de vista seamless mientras mantiene estado.

**Lógica de Cambio de Vistas** (main.py líneas 336-339):

.. code-block:: python
   :linenos:

   def switch_view(self, index):
       """Cambiar a la vista especificada"""
       self.stacked_widget.setCurrentIndex(index)

**Simple pero crítico**: Coordinación centralizada de cambio de vistas asegura gestión consistente de estado.

Características Avanzadas de Integración
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Integración de Sistema Join** (main.py líneas 605-626):

.. code-block:: python
   :linenos:

   def abrir_cruzar_datos(self):
       """Abrir diálogo para cruzar datos"""
       if self.df_vista_actual is None or self.df_vista_actual.empty:
           QMessageBox.warning(self, "Advertencia", "No hay datos cargados para cruzar.")
           return

       try:
           # Importar diálogo de join
           from app.widgets.join.join_dialog import JoinDialog

           # Crear diálogo
           dialog = JoinDialog(self.df_vista_actual, self)
           dialog.join_completed.connect(self.on_join_completed)

           if dialog.exec() == QDialog.Accepted:
               # El diálogo ya maneja la configuración, pero si se acepta sin configurar,
               # no debería pasar nada
               pass

       except Exception as e:
           QMessageBox.critical(self, "Error", f"Error abriendo diálogo de cruce de datos: {str(e)}")

**Explicación línea por línea:**

- **Líneas 606-609**: Validar disponibilidad de datos antes de abrir diálogo
- **Línea 613**: Import dinámico de diálogo de join (carga lazy)
- **Línea 616**: Crear diálogo con datos actuales
- **Línea 617**: Conectar señal de completación a manejador de resultados
- **Líneas 619-622**: Manejar aceptación de diálogo (diálogo gestiona su propia lógica)

**Decisión de Diseño**: Imports lazy reducen tiempo de inicio, validación previene errores.

**Integración de Tabla Pivote** (main.py líneas 651-672):

.. code-block:: python
   :linenos:

   def abrir_pivot_simple(self):
       """Abrir diálogo de tabla pivote simple"""
       if self.df_vista_actual is None or self.df_vista_actual.empty:
           QMessageBox.warning(self, "Advertencia", "No hay datos cargados para crear tabla pivote.")
           return

       try:
           # Importar diálogo de pivote simple
           from app.widgets.simple_pivot_dialog import SimplePivotDialog

           # Crear diálogo simplificado
           dialog = SimplePivotDialog(self.df_vista_actual, self)
           dialog.set_data(self.df_vista_actual)

           if dialog.exec() == QDialog.Accepted:
               pivot_config = dialog.get_config()
               if pivot_config:
                   self.procesar_pivot_simple(pivot_config)

       except Exception as e:
           QMessageBox.critical(self, "Error", f"Error abriendo diálogo de pivote simple: {str(e)}")

**Patrón similar**: Validación, import lazy, creación de diálogo, procesamiento de resultados.

Manejo de Errores y Recuperación
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Gestión Centralizada de Errores** (main.py líneas 464-470):

.. code-block:: python
   :linenos:

   def on_error_carga(self, error_message):
       """Slot para manejar errores de carga"""
       if hasattr(self, 'progress_dialog'):
           self.progress_dialog.close()

       QMessageBox.critical(self, "Error", f"No se pudo cargar el archivo: {error_message}")

**Decisión de Diseño**: Manejo consistente de errores en todas las operaciones, mensajes amigables para usuario.

Integración Entre Módulos
~~~~~~~~~~~~~~~~~~~~~~~~~

**Coordinación de Flujo de Datos** (main.py líneas 416-463):

El MainWindow coordina flujo de datos entre componentes:

1. **Hilo de Carga** → **MainWindow** → **Actualizaciones DataView/GraphicsView**
2. **Acciones de Usuario** → **MainWindow** → **Procesamiento Core** → **Actualizaciones de Vista**
3. **Características Avanzadas** → **Diálogos Especializados** → **MainWindow** → **Vistas de Resultados**

**Puntos Críticos de Integración:**

- Conexiones signal/slot para acoplamiento loose
- Gestión centralizada de estado
- Manejo consistente de errores
- Retroalimentación de progreso para operaciones largas

**Optimizaciones de Performance:**

- Carga con hilos para archivos grandes
- Imports lazy para diálogos
- Cambio eficiente de vistas
- Manejo de datos consciente de memoria

**Diseño de Extensibilidad:**

- Arquitectura de plugin para nuevas vistas
- Sistema de diálogo modular
- Sistema de menú configurable
- Comunicación basada en señales

Inicialización del Proceso
--------------------------

Configuración de Ventana
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   def __init__(self):
       super().__init__()
       self.setWindowTitle("Flash Sheet - Data Analysis Tool")
       self.setGeometry(100, 100, 1200, 800)
       self.setup_ui()
       self.setup_connections()

Componentes de UI
~~~~~~~~~~~~~~~~~~

El método setup_ui() crea los componentes principales de interfaz:

- **Barra de Menú**: Menús Archivo, Editar, Ver, Datos, Ayuda
- **Barra de Herramientas**: Botones de acceso rápido para operaciones comunes
- **Barra de Estado**: Indicadores de progreso y mensajes de estado
- **Widget Central**: QStackedWidget conteniendo diferentes vistas

Sistema de Vistas Arquitectura
------------------------------

Gestión de Widget Apilado
~~~~~~~~~~~~~~~~~~~~~~~~~

La aplicación usa QStackedWidget para gestionar múltiples vistas:

.. code-block:: python

   self.stacked_widget = QStackedWidget()
   self.setCentralWidget(self.stacked_widget)

   # Agregar vistas
   self.main_view = MainView()
   self.data_view = DataView()
   self.graphics_view = GraphicsView()
   self.joined_data_view = JoinedDataView()

   self.stacked_widget.addWidget(self.main_view)
   self.data_view = self.data_view
   # ... agregar otras vistas

Lógica de Cambio de Vistas
~~~~~~~~~~~~~~~~~~~~~~~~~~

Cambio de vistas se maneja a través de acciones de menú y botones de barra de herramientas:

.. code-block:: python

   def switch_to_data_view(self):
       self.stacked_widget.setCurrentWidget(self.data_view)
       self.update_menu_state()

Sistema de Menú Implementación
------------------------------

Menú Archivo
~~~~~~~~~~~~

Maneja carga de datos y ciclo de vida de aplicación:

- **Cargar Archivo**: Abrir diálogo de archivo y cargar datos
- **Cargar Carpeta**: Funcionalidad de carga por lotes
- **Guardar/Exportar**: Operaciones de exportación de datos
- **Salir**: Cierre de aplicación

Menú Datos
~~~~~~~~~~

Operaciones avanzadas de datos:

- **Unir Datos**: Operaciones cross-dataset
- **Tabla Pivote**: Resumen de datos
- **Filtrar Datos**: Interfaz de filtrado de datos
- **Transformar Datos**: Herramientas de manipulación de datos

Menú Ver
~~~~~~~~

Gestión de interfaz:

- **Vista de Datos**: Visualización de tabla
- **Vista de Gráficos**: Visualización de gráficos
- **Vista de Datos Unidos**: Resultados de join
- **Pantalla Completa**: Alternar modo pantalla completa

Flujo de Datos Coordinación
---------------------------

Pipeline de Carga de Datos
~~~~~~~~~~~~~~~~~~~~~~~~~~

1. **Selección de Archivo**: Usuario selecciona archivo(s)
2. **Detección de Formato**: Reconocimiento automático de formato
3. **Parsing de Datos**: Parsing específico de formato
4. **Validación de Datos**: Verificación de integridad y tipos
5. **Actualización de Vista**: Mostrar datos en vista apropiada
6. **Actualización de Estado**: Informar al usuario de completación

.. code-block:: python

   def load_file(self):
       file_path, _ = QFileDialog.getOpenFileName(
           self, "Load Data File", "", self.get_file_filters()
       )
       if file_path:
           try:
               data = self.data_handler.load_file(file_path)
               self.update_views_with_data(data)
               self.statusBar().showMessage(f"Loaded: {file_path}")
           except Exception as e:
               QMessageBox.critical(self, "Error", f"Failed to load file: {str(e)}")

Coordinación de Exportación
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Operaciones de exportación coordinan entre vistas y manejadores de exportación:

.. code-block:: python

   def export_data(self, format_type):
       current_view = self.stacked_widget.currentWidget()
       if hasattr(current_view, 'get_export_data'):
           data = current_view.get_export_data()
           export_handler = self.get_export_handler(format_type)
           export_handler.export(data)

Señales y Eventos
-----------------

Manejo de Eventos
~~~~~~~~~~~~~~~~~

La MainWindow conecta varias señales para mantener estado de aplicación:

- **Señales de Cambio de Vista**: Actualizar menús cuando vistas cambian
- **Señales de Cambio de Datos**: Refrescar visualizaciones cuando datos se actualizan
- **Señales de Progreso**: Mostrar progreso para operaciones largas
- **Señales de Error**: Mostrar mensajes de error al usuario

Configuración de Conexión
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   def setup_connections(self):
       # Conexiones de menú
       self.action_load_file.triggered.connect(self.load_file)
       self.action_export_csv.triggered.connect(lambda: self.export_data('csv'))

       # Conexiones de cambio de vista
       self.stacked_widget.currentChanged.connect(self.on_view_changed)

       # Conexiones de manejador de datos
       self.data_handler.data_loaded.connect(self.on_data_loaded)
       self.data_handler.progress_updated.connect(self.update_progress)

Barra de Estado Actualizaciones
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

La barra de estado proporciona retroalimentación en tiempo real:

- **Estado de Operación**: Descripción de operación actual
- **Barra de Progreso**: Indicación visual de progreso
- **Estadísticas de Datos**: Conteos de filas/columnas
- **Uso de Memoria**: Consumo de memoria actual

Diálogos de Progreso
~~~~~~~~~~~~~~~~~~~~

Para operaciones de larga duración:

.. code-block:: python

   def show_progress_dialog(self, operation_name):
       self.progress_dialog = QProgressDialog(
           f"Processing {operation_name}...", "Cancel", 0, 100, self
       )
       self.progress_dialog.setWindowModality(Qt.WindowModal)
       self.progress_dialog.show()

Manejo de Errores
-----------------

Gestión de Excepciones
~~~~~~~~~~~~~~~~~~~~~~~

Manejo centralizado de errores para mensajes amigables de usuario:

.. code-block:: python

   def handle_error(self, error, context=""):
       error_msg = f"Error {context}: {str(error)}"
       self.logger.error(error_msg)
       QMessageBox.critical(self, "Error", error_msg)

Mecanismos de Recuperación
~~~~~~~~~~~~~~~~~~~~~~~~~

- **Auto-guardado**: Guardado periódico de estado
- **Degradación Graciosa**: Continuar operación con funcionalidad reducida
- **Guía de Usuario**: Mensajes de error claros con acciones sugeridas

Puntos de Integración
---------------------

Integración de Manejador de Datos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

La MainWindow coordina con DataHandler para operaciones de datos:

.. code-block:: python

   self.data_handler = DataHandler()
   self.data_handler.data_loaded.connect(self.on_data_loaded)

Integración de Vista
~~~~~~~~~~~~~~~~~~~~

Cada vista implementa interfaces estándar para intercambio de datos:

- **set_data(data)**: Cargar datos en vista
- **get_data()**: Recuperar datos actuales
- **clear_data()**: Resetear estado de vista
- **get_export_data()**: Preparar datos para exportación

Arquitectura de Plugin
~~~~~~~~~~~~~~~~~~~~~~

Extensibilidad futura a través de interfaces de plugin:

- **Plugins de Vista**: Vistas de visualización personalizadas
- **Plugins de Exportación**: Formatos de exportación adicionales
- **Plugins de Fuente de Datos**: Capacidades de carga de datos nuevas

Consideraciones de Performance
------------------------------

Gestión de Memoria
~~~~~~~~~~~~~~~~~~

- **Carga Lazy**: Cargar datos bajo demanda
- **Cache de Vistas**: Cachear estados de vista
- **Recolección de Basura**: Limpieza explícita al cambiar vistas

Capacidad de Respuesta de UI
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- **Hilos**: Procesamiento en segundo plano para operaciones pesadas
- **Actualizaciones de Progreso**: Actualizaciones regulares de UI durante procesamiento
- **Soporte de Cancelación**: Permitir al usuario cancelar operaciones

Testing y Debugging
-------------------

Unit Testing
~~~~~~~~~~~~

Componentes de MainWindow deberían ser testeables:

- **Vistas Mock**: Testear lógica de cambio de vistas
- **Manejador de Datos Mock**: Testear flujo de datos
- **Simulación de Eventos**: Testear conexiones signal/slot

Características de Debug
~~~~~~~~~~~~~~~~~~~~~~~~

- **Logging**: Logging comprehensivo de operaciones
- **Profiling de Performance**: Identificar cuellos de botella
- **Debugging de UI**: Inspeccionar jerarquías de widgets

Mejoras Futuras
---------------

Mejoras Planificadas
~~~~~~~~~~~~~~~~~~~~

- **Interfaz de Documentos Múltiples**: Soporte para múltiples datasets simultáneamente
- **Guardado de Espacio de Trabajo**: Guardar/restaurar estado completo de aplicación
- **Sistema Deshacer/Rehacer**: Historial de operaciones y reversión
- **Características de Colaboración**: Edición simultánea multi-usuario

Extensibilidad
~~~~~~~~~~~~~~

- **API de Plugin**: Soporte de extensión de terceros
- **Sistema de Temas**: Apariencia personalizable
- **Localización**: Soporte multi-idioma
- **Accesibilidad**: Lector de pantalla y navegación por teclado